diff --git a/src/lib/node/Node.ts b/src/lib/node/Node.ts
index de4c00b..8733ed4 100644
--- a/src/lib/node/Node.ts
+++ b/src/lib/node/Node.ts
@@ -132,17 +132,6 @@ export class Node {
         // this.store = useMainStore();
     }
 
-    // onMouseDown(evt: MouseEvent) {
-    //     console.log("click");
-    //     this.store.displayNodeOnComponents(this.getPixelData(), this);
-    // }
-
-    // onDragStart(evt: DragEvent) {
-    //     console.log("dragend");
-    //     // evt.dataTransfer.setData("application/node", this);
-    // }
-
-
 
     //初始化缓冲区对象:顶点缓冲区、纹理缓冲区
     protected initBuffers(gl: WebGLRenderingContext) {
@@ -300,19 +289,16 @@ export class Node {
         return false;
       }
     
+    //draw at own canvas by common canvas
     public drawScene(){
         this.drawCanvas(this.canvas,this.gl,this.programInfo,this.buffers);
         copyFromCanvas(this.canvas,this.ownCanvas,this.size);
     }
 
 
-    //draw the result of this Node
+    //draw the result of this Node at common canvas
     protected drawCanvas(canvas:HTMLCanvasElement,gl:WebGLRenderingContext,programInfo:any,buffers:any): void {
-        // const gl = this.gl;
-        // const programInfo = this.programInfo;
-        // const buffers = this.buffers;
-        // const canvas = this.canvas;
-        console.log(canvas.width);
+
         gl.viewport(0, 0, 512,512);
         gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
         // gl.clearDepth(1.0);                 // Clear everything
@@ -386,7 +372,23 @@ export class Node {
 
     }
 
-
+    //draw to targetTexture
+    public drawFbo(){
+        const gl = this.gl;
+        // const tex = node.getTexture();
+        const fb = this.frameBuffer;
+        const targetTex = this.targetTexture;
+        //绘制到fbo中
+        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
+        gl.framebufferTexture2D(gl.FRAMEBUFFER,
+            gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTex, 0);
+        // gl.bindTexture(gl.TEXTURE_2D, tex);
+        gl.viewport(0, 0, 512, 512);
+        this.drawCanvas(this.canvas,this.gl,this.programInfo,this.buffers);
+ 
+        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
+        gl.bindTexture(gl.TEXTURE_2D, null);
+    }
 
     public calPixelData(): Uint8Array {
         const gl = this.gl as WebGL2RenderingContext;
@@ -643,23 +645,25 @@ export class Node {
         const locations = this.programInfo.uniformLocations;
         for (const input of this.inputNodes) {
             var name = this.inputNames[texIndex];
-            var texture = gl.createTexture();
+            // var texture = gl.createTexture();
 			gl.activeTexture(gl.TEXTURE0 + texIndex);
-			gl.bindTexture(gl.TEXTURE_2D, texture);
-            //设置纹理参数
-            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
-            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
-            // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
-            //设置纹理图像
-            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
-                512 , 512, 0, gl.RGBA, gl.UNSIGNED_BYTE,
-               input.pixelData);
+			gl.bindTexture(gl.TEXTURE_2D, input.targetTexture);
+            // //设置纹理参数
+            // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
+            // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
+            // // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
+            // //设置纹理图像
+            // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
+            //     512 , 512, 0, gl.RGBA, gl.UNSIGNED_BYTE,
+            //    input.pixelData);
 			gl.uniform1i(
 				locations["input"+name],
 				texIndex
 			);
 			texIndex++;
-		}
+        }
+        console.log(locations);
+
     }
     //清空输入节点纹理
     clearInputsTex(){
diff --git a/src/lib/node/connection.ts b/src/lib/node/connection.ts
index 3e6f2be..8a9f1c6 100644
--- a/src/lib/node/connection.ts
+++ b/src/lib/node/connection.ts
@@ -6,11 +6,13 @@ export class Connection {
     private inputNodes:Node [] = [];
     private currentNode:Node;
     private id:string;
-    constructor(id,inputNodes,currentNode){
+    constructor(id:string,inputNodes:Node [],currentNode:Node){
 		this.id = id;
 		this.inputNodes = inputNodes;
 		this.currentNode = currentNode;
 		for(const input of inputNodes){
+			//绘制到targetTexture
+			input.drawFbo();
 			currentNode.addInputNode(input);
 		}
 		// setTimeout(function(){
diff --git a/src/lib/node/filterNode.ts b/src/lib/node/filterNode.ts
index 98458b3..002f7ce 100644
--- a/src/lib/node/filterNode.ts
+++ b/src/lib/node/filterNode.ts
@@ -89,8 +89,8 @@ export class BlendNode extends Node{
             vec4 foreground = texture2D(inputForeground,vTexCoord);
             vec4 background = texture2D(inputBackground,vTexCoord);
             vec4 result = mix(background,foreground,propOpacity);
-            gl_FragColor= result;
-            // gl_FragColor =background;
+           
+            gl_FragColor =result;
         }        
         `
         ;
@@ -111,6 +111,6 @@ export class BlendNode extends Node{
 
         this.setInputsLocation();
         this.setPropsLocation();
-        
+
     }
 }
\ No newline at end of file
diff --git a/src/views/nodeView.vue b/src/views/nodeView.vue
index 5b2913c..e5ef955 100644
--- a/src/views/nodeView.vue
+++ b/src/views/nodeView.vue
@@ -25,13 +25,15 @@ onMounted(() => {
     //     console.log("mycanvas is exist");
     // }
 
+    
+    // const noiseNode = new SimplexNoiseNode();
+    // noiseNode.initCanvas();
 
 
-    // console.log("color");
     // const colorA = new ColorNode();
-    // drawCanvas(colorA);
-    // copyFromCanvas(colorA.canvas,canvas,colorA.size);
-    
+    // colorA.initCanvas();
+
+    // noiseNode.drawScene();
     // const pattern = new PatternNode();
     // loadImage(pattern);
     
@@ -43,17 +45,18 @@ onMounted(() => {
     // ctx.fillRect(0, 0, 100, 100);
     
     // const blend = new BlendNode();
-    // const connection = new Connection("con01",[colorA,pattern],blend);
+    // console.log(blend);
+    // blend.initCanvas();
+    // const connection = new Connection("con01",[colorA,noiseNode],blend);
+    
 
     // setTimeout(() => {
-    //     drawCanvas(blend);
-    //     copyFromCanvas(blend.canvas,canvas,blend.size);
+    //     blend.drawScene();
     // }, 2000);
 
-    // const noiseNode = new SimplexNoiseNode();
-    // noiseNode.initCanvas();
 
-    
+
+
 })
 </script>
 
